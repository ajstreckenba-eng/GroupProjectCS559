import * as T from "../libs/CS559-Three/build/three.module.js";
import { GrObject } from "../libs/CS559-Framework/GrObject.js";
import { Random, sampleUniform } from "./random.js";
import { addPillars, Monorail } from "./monorail.js";
import {
  createArtDecoMaterial,
  createBronzeMaterial,
  createCreamStoneMaterial,
} from "./materials.js";

function sampleLevel(random, width, depth, height) {
  let cornerHeight = Math.min(
    sampleUniform(random, height * 0.5, height * 1.5),
    height - 1e-2,
  );
  let cornerWidth = sampleUniform(random, (width / 2) * 0.3, (width / 2) * 0.8);
  let cornerDepth = sampleUniform(random, (depth / 2) * 0.3, (depth / 2) * 0.8);
  let baseWidth = sampleUniform(random, width * 0.7, width * 0.85);
  let baseDepth = sampleUniform(random, depth * 0.7, depth * 0.85);
  return {
    cornerHeight: cornerHeight,
    cornerWidth: cornerWidth,
    cornerDepth: cornerDepth,
    baseWidth: baseWidth,
    baseDepth: baseDepth,
    baseHeight: height,
    width: width,
    depth: depth,
  };
}

export function sampleSkyscraper(random, width, depth) {
  let levelCount = Math.pow(random.next() % 3, 2) + 2;
  let levels = [];

  let levelWidth = width;
  let levelDepth = depth;

  let levelHeight = Math.pow(sampleUniform(random, 2, 4), 1.5);
  let height = 0;

  for (let i = 0; i < levelCount; i++) {
    height += levelHeight;
    let level = sampleLevel(random, levelWidth, levelDepth, levelHeight);
    levelWidth = level.baseWidth;
    levelDepth = level.baseDepth;
    levelHeight *= sampleUniform(random, 0.6, 0.9);
    levels.push(level);
  }

  let accentMaterial = "bronze";
  if (random.next() % 2 == 0) {
    accentMaterial = "stripes";
  }

  return {
    levels: levels,
    width: width,
    depth: depth,
    height: height,
    accentMaterial: accentMaterial,
  };
}

// Generated by Claude using prompt: Can you please add function that creates an
// axis-aligned box with given dimensions and UV coordinates with (0, 0) and (1, 1)
// in opposite corners for each plane and where you can determine the index of the plane
// in a shader?
function createBoxMesh(width, depth, height) {
  const w = width / 2;
  const h = height / 2;
  const d = depth / 2;

  const positions = [];
  const normals = [];
  const uvs = [];
  const faceIds = [];

  function addQuad(v1, v2, v3, v4, normal, faceId) {
    positions.push(...v1, ...v2, ...v3);
    normals.push(...normal, ...normal, ...normal);
    uvs.push(0, 0, 1, 0, 1, 1);
    faceIds.push(faceId, faceId, faceId);

    positions.push(...v1, ...v3, ...v4);
    normals.push(...normal, ...normal, ...normal);
    uvs.push(0, 0, 1, 1, 0, 1);
    faceIds.push(faceId, faceId, faceId);
  }

  addQuad([-w, -h, d], [w, -h, d], [w, h, d], [-w, h, d], [0, 0, 1], 0);
  addQuad([w, -h, -d], [-w, -h, -d], [-w, h, -d], [w, h, -d], [0, 0, -1], 1);
  addQuad([-w, h, d], [w, h, d], [w, h, -d], [-w, h, -d], [0, 1, 0], 2);
  addQuad([-w, -h, -d], [w, -h, -d], [w, -h, d], [-w, -h, d], [0, -1, 0], 3);
  addQuad([w, -h, d], [w, -h, -d], [w, h, -d], [w, h, d], [1, 0, 0], 4);
  addQuad([-w, -h, -d], [-w, -h, d], [-w, h, d], [-w, h, -d], [-1, 0, 0], 5);

  const geometry = new T.BufferGeometry();
  geometry.setAttribute("position", new T.Float32BufferAttribute(positions, 3));
  geometry.setAttribute("normal", new T.Float32BufferAttribute(normals, 3));
  geometry.setAttribute("uv", new T.Float32BufferAttribute(uvs, 2));
  geometry.setAttribute("faceId", new T.Float32BufferAttribute(faceIds, 1));

  return geometry;
}

let skyscraperCount = 0;

export class GrSkyscraper extends GrObject {
  constructor(params = {}) {
    const group = new T.Group();

    let x = params.x || 0;
    let z = params.z || 0;
    let y = params.y || 0;

    const fogParams = params.fogParams || {
      color: new T.Color(0xffffff),
      near: 0,
      far: 8,
    };

    const baseMaterial = createCreamStoneMaterial(fogParams);

    let accentMaterial;
    if (params.accentMaterial == "bronze") {
      accentMaterial = createBronzeMaterial(fogParams);
    } else {
      accentMaterial = createArtDecoMaterial(fogParams);
    }

    for (let level of params.levels) {
      let base = createBoxMesh(
        level.baseWidth,
        level.baseDepth,
        level.baseHeight,
      );
      base.translate(x, y + level.baseHeight / 2, z);
      group.add(new T.Mesh(base, baseMaterial));

      for (let signs of [
        [-1, -1],
        [-1, 1],
        [1, -1],
        [1, 1],
      ]) {
        let corner = createBoxMesh(
          level.cornerWidth,
          level.cornerDepth,
          level.cornerHeight,
        );
        corner.translate(
          x - (signs[0] * level.width) / 2 + (signs[0] * level.cornerWidth) / 2,
          y + level.cornerHeight / 2,
          z - (signs[1] * level.depth) / 2 + (signs[1] * level.cornerDepth) / 2,
        );
        group.add(new T.Mesh(corner, accentMaterial));
      }

      y += level.baseHeight;
    }

    super(`Skyscraper-${++skyscraperCount}`, group);
  }
}

export function sampleCity(random, params = {}) {
  const gridSize = params.gridSize || 8;
  const blockSize = params.blockSize || 40;
  const roadWidth = params.roadWidth || 8;

  const buildings = [];
  const roads = [];

  // Generate the road grid
  const totalSize = gridSize * (blockSize + roadWidth) + roadWidth;

  // Horizontal roads
  for (let i = 0; i <= gridSize; i++) {
    const z = i * (blockSize + roadWidth);
    roads.push({
      type: "horizontal",
      x: 0,
      z: z,
      width: roadWidth,
      length: totalSize,
    });
  }

  // Vertical roads
  for (let i = 0; i <= gridSize; i++) {
    const x = i * (blockSize + roadWidth);
    roads.push({
      type: "vertical",
      x: x,
      z: 0,
      width: roadWidth,
      length: totalSize,
    });
  }

  for (let blockX = 0; blockX < gridSize; blockX++) {
    for (let blockZ = 0; blockZ < gridSize; blockZ++) {
      const baseX = blockX * (blockSize + roadWidth) + roadWidth;
      const baseZ = blockZ * (blockSize + roadWidth) + roadWidth;

      const padding = 0;
      const availableWidth = blockSize - padding * 2;
      const availableDepth = blockSize - padding * 2;

      const buildingWidth = sampleUniform(
        random,
        availableWidth * 0.6,
        availableWidth,
      );
      const buildingDepth = sampleUniform(
        random,
        availableDepth * 0.6,
        availableDepth,
      );

      const offsetX = (blockSize - buildingWidth) / 2;
      const offsetZ = (blockSize - buildingDepth) / 2;

      const x = baseX + offsetX;
      const z = baseZ + offsetZ;

      let skyscraper = sampleSkyscraper(random, buildingWidth, buildingDepth);
      skyscraper.x = x;
      skyscraper.z = z;
      skyscraper.y = 0;

      buildings.push(skyscraper);
    }
  }

  return {
    buildings: buildings,
    roads: roads,
    gridSize: gridSize,
    blockSize: blockSize,
    roadWidth: roadWidth,
    totalSize: totalSize,
  };
}

let cityCount = 0;

export class GrCity extends GrObject {
  constructor(params = {}) {
    const group = new T.Group();

    let random = new Random(params.seed || 12345);
    const cityDescriptor = sampleCity(random, params);

    for (let buildingDesc of cityDescriptor.buildings) {
      const skyscraper = new GrSkyscraper(buildingDesc);
      group.add(skyscraper.objects[0]);
    }

    let monorails = [6, 8, 10].map((height) => {
      let monorail = new Monorail(
        random,
        params.gridSize,
        height,
        params.blockSize,
        params.roadWidth,
      );
      group.add(monorail.mesh);
      group.add(monorail.car);
      return monorail;
    });

    addPillars(group, monorails, params.blockSize, params.roadWidth);

    super(`City-${++cityCount}`, group);
    this.cityDescriptor = cityDescriptor;
    this.monorails = monorails;
  }

  stepWorld(delta, timeOfDay) {
    for (let monorail of this.monorails) {
      monorail.step(delta);
    }
  }
}
